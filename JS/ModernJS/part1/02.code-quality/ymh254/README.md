# 2. 코드 품질

## 🔮 이건 꼭 기억해야해!
> 좋은 주석

- 아키텍처를 설명하는 주석

  (고차원 수준 컴포넌트 개요, 컴포넌트 간 상호작용에 대한 설명, 상황에 따른 제어 흐름)	

- 함수 용례와 매개변수 정보를 담고 있는 주석

- 왜 이런 방법으로 문제를 해결했는지 설명하는 주석

- 미묘한 기능이 있고, 그 기능이 어디에 쓰이는지를 설명하는 주석

- 설명이 담긴 주석은 좋지 않음

> 테스팅 자동화
>
> (테스트 코드가 실제 동작에 관여하는 코드와 별개로 작성되었을 때 가능)

##### BDD (Behavior Driven Development)

: 테스트, 문서, 예시를 한데 모아놓은 개념

- 스펙(or 명세서): 코드가 무슨 일을 하는지 자연어로 표현한 것

  - describe("title", function(){}) : 구현하고자 하는 기능에 대한 설명을 하고 it블록을 한데 모아주는 역할

    (하위그룹 정의시 중첩 describe사용 가능)

  - it("유스 케이스 설명", function(){})

  - assert.*(value1, value2) : it 블록 내의 코드

  ```
  ex)
  describe("pow", function() {
  	it("주어진 숫자의 n제곱", function() {
  		assert.equal(pow(2, 3), 8)
  	})
  })
  
  //여기서 assert.equal은 두 인수가 동등한지 비교 (false일 때 에러 반환)
  ```

##### 개발 순서

1. 명세서 초안을 작성 (기본적인 테스트 포함하되 테스트 하나에 한 가지씩 확인할 것)
2. 명세서 초안을 보고 코드를 작성
3. 코드가 작동하는지 확인하기 위해 [Mocha](http://mochajs.org/)라 불리는 테스트 프레임워크를 사용해 명세서를 실행 (에러가 더는 출력되지 않을 때까지 코드를 수정)
4. 모든 테스트를 통과하는 코드 초안이 완성
5. 명세서에 지금까진 고려하지 않았던 유스케이스 몇 가지를 추가 (=> 실패하는 유스케이스 등장)
6. 세 번째 단계로 돌아가 테스트를 모두 통과할 때까지 코드를 수정
7. 기능이 완성될 때까지 3~6단계를 반복

##### 스펙 실행

- Mocha: 핵심 테스트 프레임워크

  (describe, it와 같은 테스팅 함수와 실행 관련 주요 함수 제공)

- Chai: 다양한 assertion을 제공해 주는 라이브러리

- Sinon: 함수의 정보를 캐내는데 사용되는 라이브러리 (내장함수 등을 모방함)

(karma같은 고수준의 테스트러너를 사용하면 다양한 종류의 테스트를 자동으로 실행 가능)

## 🧐면접관처럼 질문할 목록

##### CrossBrowsing

: 어떤 브라우저를 사용하든 구현된 웹페이지의 뷰를 동일하게 보여주는 것

>  바벨

: Transpiler로, 최신 자바스크립트 코드를 구 표준을 준수하는 코드로 바꿔줌 (재작성)

=> 바벨은 ESNext(출시되지 않은 JS 버전)에서 지원하는 문법을 ES5 문법으로 번역

>  Polyfill

: IE같은 구형 부라우저에서 최신 자바스크립트 문법이나 CSS 성질들이 제대로 작동하지 않는 경우 구현된 웹페이지의 뷰를 제대로 동작시키기 위해 코드를 덧붙이는 작업

Ex)  Map, Promise, Set 등을 사용가능한 객체로 만들어줌

> Webpack

: 프로젝트 빌드 시스템으로, 모던 프로젝트 빌드 시스템은 코드가 수정될 때마다 자동으로 트랜스파일러를 동작시켜줌

(= Module budling -> html에 적용되는 연관되어 있는 자바스크립트 파일들을 종성성이 있는 하나의 파일로 묶어줌)

- Loader: Webpack이 javascrip, image, css를 하나의 번들로 만들때 사용

- Plugins: loader가 파일단위로 번들링을 처리하는 반면에 플러그인은 번들된 결과물을 처리

  - bundle된 결과물을 HTML파일로 생성
  - 웹팩이 빌드하는데 걸린 시간 등을 처리

- Mode

  : 웹팩의 번들링은 빌드 모드에 따라서 차이가 있다

  - Development: 빠르게 빌드하기 위해서 빌드할때 최적화를 안하는 특징   
  - Production: 빌드할때 최적화 작업을 함 (기본적인 파일 압축 등) 
  - none   모드를 설정하지 않는다

- Code splitting을 통해 사용자가 현재 필요로 하는 것들만 loading하게 되어 시간을 단축 (만약 웹팩으로 번들링된 파일의 용량이 너무 크다면 해당 파일을 읽어오는데 상당히 오랜 시간이 걸림)

Why? 웹페이지 성능 최적화!

-  파일을 컴파일 할 때, 여러 모듈들의 파일을 읽어오는데 시간이 오래 걸리는 부분을 해결하기 위해 여러 파일을 하나의 파일로 번들링함
-  모던 프로젝트 빌드 시스템은 코드가 수정될 때마다 자동으로 트랜스파일러를 동작시킴



## 👻 공부하면서 어렵거나 중요한 개념 정리
> Chrome으로 Debugging하기
>
> : 브라우저에서 개발자 도구 안의 Sources 패널에서 가능

(스크립트 내에 console.log 함수를 이용하여 원하는 것을 콘솔에 출력함으로써 디버깅 가능)

##### 중단점 (Breakpoint)

: 자바스크립트의 실행이 중단되는 코드 내 지점

- 줄 번호 클릭을 함으로써 설정

- 변수가 어떤 값을 담고 있는지 알 수 있음

- 실행이 중지된 시점을 기준으로 명령어 실행 가능 (디버깅 가능)

  - 항목을 클릭해 해당 중단점이 설정된 곳으로 바로 이동 가능
  - 체크 박스 해제시 해당 중단점 비활성화
  - 마우스 오른쪽 버튼 클릭 시 나오는 Remove breakpoint 옵션을 통해 중단점 삭제 등 다양한 기능 사용 가능

  - 조건부 중단점

    : 줄 번호 위에 커서를 놓고 마우스 오른쪽 오른쪽 버튼 클릭시 조건부 중단점(conditional breakpoint) 설정가능

    => 표현식을 입력하면 표현식이 참인 경우에만 실행 중지 (디버깅시 유용)

- 스트립트 내에 debugger 명령어를 사용하면 중단점과 같은 역할을 함

##### 디버깅 영역

: 설정된 중단점 시점에서 결과를 보여주는 영역

- Watch - 표현식을 평가하고 결과를 보여줌
- Call Stack - 코드를 해당 중단점으로 안내한 실행 경로를 역순(쌓인 순)으로 표시
- Scope - 현재 정의된 모든 변수를 출력